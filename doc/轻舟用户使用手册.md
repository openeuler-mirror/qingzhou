# 轻舟用户使用手册

## 概述

轻舟是一款开源的轻量级软件开发平台，其愿景是优化通用型Web管理软件的开发质量与效率，并实现不同类型软件的集中化统一管理。
基于轻舟开发Web管理软件，只需编写简单的Java
Bean，即可自动获得业务模块对应的前端网页、REST接口、JMX接口、国际化等服务，并能开箱即用内置的用户管理、认证授权、监视自动化、文件上传下载、本地和远程集中管理、公共组件等能力。
在轻舟的架构里，管理一种类型的软件被设计为一种应用，应用可被按需地、灵活地插拔于轻舟平台之上，并获得可配置、可观测等效益，从而优化企业内部复杂的业务系统的管理工作。

## 安装运行

轻舟支持主流操作系统，如 Windows、Ubuntu、openEuler 或其他 Unix-Like 的发行版上。

### **先决条件**
为了能正确安装和使用轻舟平台，你需要首先确保已经配置以下环境：

- Java 8 及以上版本
- Apache Maven 最新版本或推荐版本

### **拉取仓库**
复制以下命令到终端执行
`git clone https://gitee.com/openeuler/qingzhou.git`

或直接下载压缩文件到本地解压
### **编译安装**

在项目根目录执行 `mvn clean install` 命令，然后可在项目的 `package/target/qingzhou` 得到轻舟的安装包。
> 其中：
>
> **bin**：为轻舟的可执行程序目录，包含不同平台的脚本文件等；
>
> **instances**：为轻舟的实例存放目录，包含轻舟的配置文件和应用的业务数据等；
>
> **lib**：为轻舟的程序文件，以轻舟的版本号为规划，按目录存放。

### **启动服务**

启动轻舟有两种方式，**择其一**即可：

- 在 `${轻舟的安装包}/bin` 下，执行对应平台的 start 脚本；
- 执行命令：`java -jar ${轻舟的安装包}/bin/qingzhou-launcher.jar instance start`

> 看到类似如下的日志输出，则表示启动完成：
>
> Open a browser to access the Qingzhou console: http://localhost:9000/console

### **访问控制台**

打开浏览器访问轻舟的管理平台：
[http://localhost:9000/console](http://localhost:9000/console)

在控制台页面上打开“业务管理”-“应用”，根据提示部署一个应用包，关于如何开发一个应用，请参考后文。

> 注：
>
> 若遇到浏览器页面提示 IP 不受信任，可设置轻舟的配置文件`${轻舟的安装包}/instances/instance1/conf/qingzhou.json`，
> 修改其中的 trustedIp 值，指定一个浏览器IP正则表达式来信任特定的浏览器，设置为 * 表示信任所有浏览器。

## 应用开发(快速开始)

为了让你先快速了解轻舟，我们首先完成一个简单的例子，熟悉轻舟的开发流程，其中会对必要的模块简单介绍，更为详细的模块设计和 API 方法介绍在后文介绍

基于轻舟开发应用，只需简单的几步：

1. 在 IDE 中建立一个 Java 项目工程。
2. 在工程里引入轻舟的 qingzhou-api.jar，对于 maven 项目，可通过如下方式：

   ```xml
    <dependency>
         <groupId>qingzhou</groupId>
         <artifactId>qingzhou-api</artifactId>
         <version>x.x.x</version>
         <scope>system</scope>
         <systemPath>/path/to/qingzhou/lib/versionx/qingzhou-api.jar</systemPath>
     </dependency>
   ```

---   

### 入口类

3. 创建一个类作为应用的入口，使其实现 `qingzhou.api.QingzhouApp` 接口。

   该类在 `qingzhou-api` 内，后文提到的轻舟的类也都在其内。

   实现 `start` 方法以定制应用的启动逻辑。`start` 方法会接收一个 `qingzhou.api.AppContext` 的实例对象，应用通过该对象与平台交互。

4. 给入口类添加 `@App` 注解，以使得轻舟可以识别到它。

   ```java
    import qingzhou.api.App;
    import qingzhou.api.AppContext;
    import qingzhou.api.QingzhouApp;
    
    @App
    public class Main implements QingzhouApp {
    public static final String MENU_1 = "MENU_1";
    public static final String MENU_11 = "MENU_11";
    @Override
    public void start(AppContext appContext) throws Exception {
    //添加一或多级菜单
    appContext.addMenu(MENU_1, new String[]{"一级菜单", "en:1"}).icon("folder-open").order(1);
    appContext.addMenu(MENU_11, new String[]{"二级菜单", "en:11"}).icon("leaf").order(1).parent(MENU_1);
    }

    @Override
    public void stop() throws Exception {
        //应用停止
    }
   }
   ``` 
截至目前的工作，我们可以跳到第 7 步，将工程打包并且部署到轻舟上，不过目前的工程中并没有内容，我们需要创建模块类以实现各种业务。

---   

### 模块类

5. 创建应用的模块类，**使其继承自 `qingzhou.api.ModelBase`**，根据需要实现不同的接口。

```
Add 接口：定义了对象的创建能力
Delete 接口：定义了删除操作的相关行为
List 接口：提供列表展示功能的接口
Show 接口：定义了展示数据的能力
Update 接口：提供与编辑和更新操作相关的功能定义
```

以上为常用的接口（详细的 API 介绍在后文），不过我们也可以使用 General 接口它继承了以上的五个接口

对该类添加 `@Model` 注解以设置模块的名称、图标、菜单、国际化等信息。

   ```java
    @Model(code = "user",//模块名称
        icon = "user",//图标
        menu = Main.MENU_1, order = 1,//所属菜单和在该菜单中的顺序
        name = {"用户", "en:User"},//当菜单块名
        info = {"这是一个用户模块。", "en:Menu description."})//菜单描述
    public class User extends ModelBase implements General{
    }   
   ```
在该类内部创建 **public** 的属性（自动对应到页面上的表单元素），并对其添加 `@ModelField`
注解以设置属性的相关信息。

   ```java
    @ModelField(
        required = true,
        list = true,
        name = {"用户ID", "en:User ID"},
        info = {"用户ID。", "en:User ID."})
    public String id;
    @ModelField(
        list = true,
        name = {"用户名", "en:User Name"},
        info = {"用户的姓名。", "en:User name."})
    public String name;
    @ModelField(
        list = true,
        name = {"联系方式", "en:Property"},
        info = {"用户的联系方式。", "en:Contact information for the user."})
    public String tel;
    @ModelField(
        list = true,
        min = 1,
        max = 200,
        name = {"年龄", "en:Property"},
        info = {"用户的年龄。", "en:User age."})
    public int age;
    @ModelField(
        list = true,
        name = {"住址", "en:Property"},
        info = {"用户住址。", "en:User address."})
    public String addr;
   ```
在该类内部创建方法（自动对应到页面上的按钮或链接），并对其添加 `@ModelAction`
注解以设置方法的相关信息。
   ```java
    @ModelAction(
        code = "share", icon = "share-alt",
        action_type = ActionType.action_list,
        name = {"头部按钮", "en:Share"},
        info = {"头部按钮", "en:Share"})
    public void share(Request request) {
        System.out.println("点击了头部按钮。。。");
    }

    @ModelAction(
        code = "upload", icon = "upload-alt",
        action_type = ActionType.upload,
        name = {"上传", "en:upload"},
        info = {"将本地文件或数据发送到服务器进行存储和处理。",
                "en:Send local files or data to a server for storage and processing."})
    public void upload(Request request) throws Exception {
        System.out.println("文件已上传至临时目录：" + request.getParameter("upload"));
    }
    @Override
    public String[] headActions() {
        return new String[]{Add.ACTION_CREATE, "share", "upload"};
    }
   ```
关于配置的具体接口，可查看对应的 Javadoc,以及后文更详细的 API 介绍，以下是该 User 模块类的完整实现

   ```java
    @Model(code = "user",//模块名称
        icon = "user",//图标
        menu = Main.MENU_1, order = 1,//所属菜单和在该菜单中的顺序
        name = {"用户", "en:User"},//当菜单块名
        info = {"这是一个用户模块。", "en:Menu description."})//菜单描述
    public class User extends ModelBase implements General {
    @ModelField(
            required = true,
            list = true,
            name = {"用户ID", "en:User ID"},
            info = {"用户ID。", "en:User ID."})
    public String id;
    @ModelField(
            list = true,
            name = {"用户名", "en:User Name"},
            info = {"用户的姓名。", "en:User name."})
    public String name;
    @ModelField(
            list = true,
            name = {"联系方式", "en:Property"},
            info = {"用户的联系方式。", "en:Contact information for the user."})
    public String tel;
    @ModelField(
            list = true,
            min = 1,
            max = 200,
            name = {"年龄", "en:Property"},
            info = {"用户的年龄。", "en:User age."})
    public int age;
    @ModelField(
            list = true,
            name = {"住址", "en:Property"},
            info = {"用户住址。", "en:User address."})
    public String addr;
    @ModelAction(
            code = "share", icon = "share-alt",
            action_type = ActionType.action_list,
            name = {"头部按钮", "en:Share"},
            info = {"头部按钮", "en:Share"})
    public void share(Request request) {
        System.out.println("点击了头部按钮。。。");
    }

    @ModelAction(
            code = "upload", icon = "upload-alt",
            action_type = ActionType.upload,
            name = {"上传", "en:upload"},
            info = {"将本地文件或数据发送到服务器进行存储和处理。",
                    "en:Send local files or data to a server for storage and processing."})
    public void upload(Request request) throws Exception {
        System.out.println("文件已上传至临时目录：" + request.getParameter("upload"));
    }
    @Override
    public String[] headActions() {
        return new String[]{Add.ACTION_CREATE, "share", "upload"};
    }
    @Override
    public void addData(Map<String, String> data) throws Exception {

    }
    @Override
    public void updateData(Map<String, String> data) throws Exception {

    }
    @Override
    public void deleteData(String id) throws Exception {

    }
    @Override
    public List<String[]> listData(int pageNum, int pageSize, String[] showFields, Map<String, String> query) throws IOException {
        List<String[]> data = new ArrayList<>();
        return data;
    }
    @Override
    public Map<String, String> showData(String id) throws Exception{
        Map<String, String> data = new HashMap<>();
        return data;
    }

}
   ```

6. 模块类中需要复写 General 接口中的方法，来实现数据的增删改查，接口中定义了对数据进行存储、获取、更新和删除的方法规范。以上例子中，并没有对应方法复写的实际意义，
在源码 qingzhou.app.Example 中的 AddModelBase 和 MemoryDataStoreDemo 中有较为完整的实现，可供参考

  ```java
public class AddModelBase extends ModelBase implements General {

    private final MemoryDataStoreDemo testData = new MemoryDataStoreDemo(idField());

    @Override
    public void addData(Map<String, String> data) {
        testData.addData(data);
        ExampleMain.logger.info("addData:" + data);
    }

    @Override
    public void deleteData(String id) {
        testData.deleteData(id);
        ExampleMain.logger.info("deleteData:" + id);
    }

    @Override
    public String[] allIds(Map<String, String> query) {
        return testData.allIds(query);
    }

    @Override
    public List<String[]> listData(int pageNum, int pageSize, String[] showFields, Map<String, String> query) {
        return testData.listData(pageNum, pageSize, showFields, query);
    }

    @Override
    public int totalSize(Map<String, String> query) {
        return testData.totalSize(query);
    }

    @Override
    public Map<String, String> showData(String id) {
        return testData.showData(id);
    }

    @Override
    public void updateData(Map<String, String> data) {
        testData.updateData(getAppContext().getCurrentRequest().getId(), data);
        ExampleMain.logger.info("updateData:" + data);
    }

    @Override
    public int pageSize() {
        return 3;
    }
}
   ```

7. 打包工程

根据项目工程结构需要，可选择 jar 包或 zip 两种格式

+ 打成jar包需要将项目依赖打包到一起为一个jar包即可；
+ 打成zip包，则需要将上述注解标注的类所在的jar（如app.jar）放入zip包根目录，其依赖的其它资源包， 可在MANIFEST.MF 中配置
  Class-Path 加入资源文件目录,MANIFEST.MF 配置内容如：`Class-Path: lib/resource.jar`。

```
zip包目录结构示意：
  - app.zip
      - lib
          - resource.jar
      - app.jar
          - MANIFEST.MF
```

8. 访问轻舟的可视化管理平台，在`集中管理->业务管理->应用`模块下，安装上述应用的 jar 包或者 zip 包，至此，已完成应用的开发和部署
9. 后续，可通过轻舟的可视化管理平台对应用进行管理

## 模块设计与注解说明
### ModelBase
正如前文所提到的，ModelBase 是轻舟框架中所有模块的基础类，
定义了模块的基本结构和行为规范。所有的模块（即用 @qingzhou.api.Model 
注解标注的类）**都需要继承自此类**，从而实现模块的统一管理和生命周期控制。
```java
@Model(code = "user",//模块名称
        icon = "user",//图标
        menu = Main.MENU_1, order = 1,//所属菜单和在该菜单中的顺序
        name = {"用户", "en:User"},//当菜单块名
        info = {"这是一个用户模块。", "en:Menu description."})//菜单描述
public class User extends ModelBase implements General {
    
}
```
### 注解说明
#### @App

`@App` 是轻舟框架中用于标记应用入口类的注解。
凡是被该注解标注的类，会被框架识别为应用程序的启动类。

- 标识应用入口：轻舟框架通过扫描使用 @App 注解的类，将其作为应用启动的核心类进行管理和初始化。
- 与框架集成：该注解是轻舟框架自动化管理的一部分，确保框架可以加载、启动并管理应用生命周期。

#### @Model

`@Model` 是轻舟框架中用于定义模块（模型）元数据的注解。通过该注解，开发者可以为模块（模型）
提供基本的信息配置，方便轻舟框架对模块的管理、UI展示以及菜单构建。

- 模块描述：定义模块的名称、图标、描述等基本属性，用于展示在前端界面。
- 菜单配置：设置模块的所属菜单、排序顺序、是否隐藏等菜单相关信息。
- 模型初始化：为模型提供元数据，便于轻舟框架自动生成 REST 接口、菜单项以及初始化逻辑。

#### @ModelAction

`@ModelAction` 是轻舟框架中用于定义模型操作的注解。它允许开发者为模型（模块）的方法指定操作元数据，
例如操作的名称、描述、图标、交互方式、关联表单字段等。通过该注解，轻舟框架可以自动生成对应的用户界面和操作逻辑。

- 操作描述：定义模型方法的操作名称、详细信息、可用条件等，用于生成前端的按钮、菜单等交互元素。
- UI 集成：提供与操作关联的图标、表单字段、跳转页面等配置信息。
- 操作类型：支持各种交互类型，例如页面链接、子表单提交等。

    ```java
  @ModelAction(
  code = "upload", icon = "upload-alt",
  action_type = ActionType.upload,
  name = {"上传", "en:upload"},
  info = {"将本地文件或数据发送到服务器进行存储和处理。",
  "en:Send local files or data to a server for storage and processing."})
  public void upload(Request request) throws Exception {
  System.out.println("文件已上传至临时目录：" + request.getParameter("upload"));
  }
  @Override
  public String[] headActions() {
  return new String[]{Add.ACTION_CREATE, "upload"};
  }
   ```
#### @ModelField

`@ModelField` 是轻舟框架中用于标注模型字段的注解。它应用于字段级别，允许开发者为字段添加详细的元数据描述，
包括字段的名称、分组、显示方式、验证规则等。通过该注解，框架可以动态生成用户界面的表单、列表以及字段的校验逻辑。

具体属性说明见 Javadoc

- 定义字段的基本属性，如名称、描述、分组等。
- 指定字段的显示类型、是否必填、正则校验规则等验证逻辑。
- 配置字段在表单、列表或其他页面的显示行为，如是否可编辑、是否隐藏、标签显示等。
- 配合框架生成 UI 界面和数据处理逻辑。

```java
@ModelField(
    name = {"用户名", "en:Username"},
    info = {"请输入用户名", "en:Please enter username"},
    required = true,
    input_type = InputType.text,
    placeholder = "请输入用户名",
    max_length = 20
)
private String username;

```
## API 方法介绍
### type API
#### Add
`qingzhou.api.type.Add` 接口是一个通用的"添加"能力描述，它抽象了数据插入的逻辑，
既可以用于具体的数据模型，也可以扩展到更广泛的场景，
如表单数据的动态提交、配置项的追加等。[源代码](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/type/Add.java)
方法：`void addData(Map<String, String> data) throws Exception;`

---
#### Delete
`qingzhou.api.type.Delete` 定义了删除操作的相关行为。用于根据指定的标识符（id）删除对应的数据。[源代码](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/type/Delete.java)

方法：`void deleteData(String id) throws Exception;`

---
#### Update

`qingzhou.api.type.Update` 接口定义了与编辑和更新操作相关的功能，主要用于支持基于表单的编辑和数据更新操作。
[源代码](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/type/Update.java)

| 方法名                | 说明                     | 参数                  | 返回值                          | 异常          |
|--------------------|------------------------|---------------------|------------------------------|-------------|
| `editData`         | 获取指定 ID 的编辑数据，用于初始化表单。 | `id` - 数据的唯一标识符     | `Map<String, String>` - 编辑数据 | `Exception` |
| `updateData`       | 提交更新后的数据并保存。           | `data` - 包含更新内容的键值对 | `void`                       | `Exception` |
| `formActions` (默认) | 返回可用的表单操作列表。           | 无                   | `String[]` - 表单操作数组          | 无           |

---

##### 常量定义

| 常量名             | 说明     | 值          |
|-----------------|--------|------------|
| `ACTION_EDIT`   | 表示编辑操作 | `"edit"`   |
| `ACTION_UPDATE` | 表示更新操作 | `"update"` |
---
#### List
`qingzhou.api.type.List` 接口提供模块化的列表展示功能，
并支持分页、搜索以及数据的增删改查操作。继承自 Showable 接口，支持常见的列表展示需求。
源码中有较为详细的 Javadoc [源代码](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/type/List.java)

##### **方法列表**

| **方法名**                   | **描述**            | **返回值**                        | **默认实现**                                       |
|---------------------------|-------------------|--------------------------------|------------------------------------------------|
| `listData`                | 获取分页列表数据。         | `java.util.List<String[]>`     | 无                                              |
| `idField`                 | 获取用于标识数据 ID 的字段名。 | `String`                       | 返回 `"id"`。                                     |
| `allIds`                  | 获取所有数据的 ID。       | `String[]`                     | 返回 `null`，表示无效。                                |
| `contains`                | 判断是否包含指定 ID 的数据。  | `boolean`                      | 遍历 `allIds`，若找到匹配的 ID，则返回 `true`。              |
| `totalSize`               | 获取数据总条数。          | `int`                          | 通过 `allIds` 的长度计算，若 `allIds` 为 `null`，返回 `-1`。 |
| `pageSize`                | 获取每页的数据条数。        | `int`                          | 返回 `10`。                                       |
| `headActions`             | 定义列表顶部的操作。        | `String[]`                     | 返回 `{"create"}`，表示支持创建操作。                      |
| `batchActions`            | 定义列表批量操作。         | `String[]` 或 `null`            | 返回 `null`，表示无批量操作。                             |
| `listActions`             | 定义列表中每条数据支持的操作。   | `String[]`                     | 返回 `{"edit", "delete"}`，表示支持编辑和删除操作。           |
| `defaultSearch`           | 设置进入列表页面默认的搜索条件。  | `Map<String, String>` 或 `null` | 返回 `null`，表示无默认搜索条件。                           |
| `useDynamicDefaultSearch` | 判断是否启用动态默认搜索。     | `boolean`                      | 返回 `false`，表示不启用动态默认搜索。                        |
| `showOrderNumber`         | 判断列表是否显示序号。       | `boolean`                      | 返回 `true`，表示显示序号。                              |

---
#### Show
`qingzhou.api.type.Show` 接口定义了展示数据的能力，允许通过指定的 ID 获取一组键值对形式的数据。

##### 方法说明

| **方法签名**                                  | **描述**                              |
|-------------------------------------------|-------------------------------------|
| `Map<String, String> showData(String id)` | 根据给定的 ID 返回数据，数据以键值对 (`Map`) 的形式组织。 |

---
#### General
`qingzhou.api.type.General` 接口是一个通用模型接口，它继承了以上五个功能性接口，整合了模型常见的操作能力，
包括 添加 (Add)、删除 (Delete)、更新 (Update)、列表查询 (List)、以及展示 (Show)。

---
#### Group
`qingzhou.api.type.Group` 定义了分组数据的生成功能，用于返回一组分组项信息。

##### 方法：groupData()

| 方法名称 | groupData()                      |
|------|----------------------------------|
| 描述   | 返回包含分组数据的数组，每个分组项表示一个分组类别及其相关信息。 |
| 返回类型 | Item[]                           |
| 异常   | 无                                |

##### 实现示例

```java
@Override
public Item[] groupData() {
    return new Item[]{
        Item.of("base", new String[]{"基本信息", "en:Base"}),
        Item.of("org", new String[]{"组织关系", "en:Org"})
    };
}
```
---
#### Monitor
`qingzhou.api.type.Monitor` 监控接口，定义了监控数据的获取方法。该接口用于让实现类提供监控数据，以供监控系统收集和处理。

##### 方法：monitorData()

| 方法名称 | monitorData(String id)                                  |
|------|---------------------------------------------------------|
| 描述   | 获取包含监控数据的键值对集合。每个键值对代表一个监控数据项，其中键表示监控数据的名称，值表示监控数据的当前值。 |
| 参数   | id：监控数据的唯一标识符。                                          |
| 返回类型 | Map<String, String>                                     |
| 异常   | Exception                                               |

##### 实现示例

```java
@Override
public Map<String, String> monitorData(String id) throws Exception {
    Map<String, String> monitorDataMap = new HashMap<>();
    // 假设这里是获取监控数据的逻辑
    monitorDataMap.put("CPU Usage", "75%");
    monitorDataMap.put("Memory Usage", "50%");
    monitorDataMap.put("Disk Usage", "30GB of 1TB");
    return monitorDataMap;
}
```

---
#### Download

`qingzhou.api.type.Download` 接口定义了与下载相关的操作，包括获取文件列表和具体的文件下载功能。[源代码](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/type/Download.java)

方法：`File downloadData(String id) throws Exception;`

实现案例：
```java
@Override
    public File downloadData(String id) {
        return new File(new File(getAppContext().getAppDir(), FILE_BASEDIR), id);
    }
```
---

#### Echo
`qingzhou.api.type.Echo` 接口定义了在 Qingzhou 平台中实现表单数据联动的功能。
通过 echoData 方法，开发者可以实现根据输入参数动态更新表单字段的值和选项。

##### 方法参数

| 方法         | 参数名称          | 类型                    | 说明                          |
|------------|---------------|-----------------------|-----------------------------|
| `echoData` | `echoGroup`   | `String`              | 联动组名称，用于分组管理多个字段联动逻辑。       |
|            | `params`      | `Map<String, String>` | 当前表单的键值对参数，用于根据字段当前值执行联动逻辑。 |
|            | `dataBuilder` | `DataBuilder`         | 数据构建器，用于向前端提供更新后的字段值和选项。    |


实现案例：
```java
    @Override
    public void echoData(String echoGroup, Map<String, String> params, DataBuilder dataBuilder) {
        if ("aa".equals(echoGroup)) {
            if ("0".equals(params.get("gender"))) {
                dataBuilder.addData("position", "003");
                dataBuilder.addData("department", "一部");
                dataBuilder.addData("subjects1", "123," + params.get("gender"));
                dataBuilder.addData("checkbox", "python");
                dataBuilder.addData("subjects2", "3,2");
                dataBuilder.addData("kv", "a=123@b=addf");
            } else {
                dataBuilder.addData("position", "002");
                dataBuilder.addData("department", "二部");
                dataBuilder.addData("subjects1", params.get("gender"));
                dataBuilder.addData("checkbox", "js");
                dataBuilder.addData("subjects2", "1,2");
                dataBuilder.addData("kv", "hello=world@lang=");
            }
            dataBuilder.addData("notes", params.get("gender"));
        }
    }
```
---

#### Export
`qingzhou.api.type.Export` 提供数据导出功能，通过 exportData 方法获取导出数据，支持分段读取。[源代码](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/type/Export.java)

---

##### Export 接口文档

| **名称**       | `Export` 接口                                                  |
|--------------|--------------------------------------------------------------|
| **描述**       | 提供数据导出功能，通过 `exportData` 方法获取导出数据，支持分段读取。                    |
| **常量**       | `String ACTION_EXPORT = "export"` - 表示导出操作的标识。               |
| **方法**       |                                                              |
| `exportData` | **描述**：根据指定的 ID 获取导出的数据供应器。                                  |
|              | **签名**：`DataSupplier exportData(String id) throws Exception` |
|              | **参数**：`id` - 数据唯一标识符。                                       |
|              | **返回值**：`DataSupplier` - 数据供应器，用于分段读取数据。                     |
|              | **异常**：可能抛出 `Exception`，如数据无法获取时。                            |

---

##### DataSupplier 接口文档

| **名称**   | `DataSupplier` 接口                                    |
|----------|------------------------------------------------------|
| **描述**   | 数据供应器接口，用于分段读取导出的数据并提供相关元信息。                         |
| **方法**   |                                                      |
| `read`   | **描述**：从指定偏移量开始读取一段数据。                               |
|          | **签名**：`byte[] read(long offset) throws IOException` |
|          | **参数**：`offset` - 起始偏移量，单位为字节。                       |
|          | **返回值**：`byte[]` - 读取的二进制数据段。                        |
|          | **异常**：可能抛出 `IOException`，如读取失败时。                    |
| `offset` | **描述**：获取当前的偏移量。                                     |
|          | **签名**：`long offset()`                               |
|          | **返回值**：`long` - 当前数据读取的偏移量。                         |
| `name`   | **描述**：获取导出数据的名称（可选）。                                |
|          | **签名**：`default String name()`                       |
|          | **返回值**：`String` - 导出数据的名称，默认返回 `null`。              |

---

##### 示例用法

```java
@Override
public DataSupplier exportData(String id) {
   // 获取当前请求对象
   Request request = getAppContext().getCurrentRequest();

   return new DataSupplier() {
      // 定义导出文件的格式
      private final String format = "png";

      @Override
      public byte[] read(long offset) throws IOException {
         // 获取用于生成 TOTP 密码的加密服务
         TotpCipher totpCipher = Main.getService(CryptoService.class).getTotpCipher();

         // 生成一个 TOTP 密钥
         String keyForOtp = totpCipher.generateKey();

         // 将生成的密钥存储到会话参数中，用于后续校验
         request.parametersForSession().put(KEY_IN_SESSION_FLAG, keyForOtp);

         // 设置 HTTP 响应的内容类型为图片
         request.getResponse().setContentType("image/" + format);

         // 获取当前登录用户
         String loginUser = request.getUser();

         // 构建 TOTP 的 otpauth URL，用于二维码生成
         String qrCode = "otpauth://totp/" + loginUser + "?secret=" + keyForOtp;

         // 使用二维码生成服务生成二维码图片
         QrGenerator qrGenerator = Main.getService(QrGenerator.class);
         return qrGenerator.generateQrImage(qrCode, format, 9, 4, 0xE0F0FF, 0x404040);
      }

      @Override
      public long offset() {
         // 固定返回 -1，表示没有分段数据
         return -1L;
      }

      @Override
      public String name() {
         // 定义导出文件的名称，包括格式
         return "keyForOtp." + format;
      }
   };
}

```

##### 备注
- **用途**：`Export` 接口适用于数据导出场景，提供高效的分段数据读取方式，避免一次性加载大数据到内存。
- **扩展性**：实现 `DataSupplier` 接口时可以灵活定义数据的来源，如数据库、文件或实时生成的内容。

---

#### Chart
`qingzhou.api.type.Chart` 接口定义了模型的图表展示能力，提供了向用户界面绘制数据图表的标准方法。它允许开发者以灵活的方式构建和展示图表数据，例如折线图、柱状图等。
[源代码](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/type/Chart.java)

该接口的设计主要用于：

- 在轻舟平台中提供图表支持。
- 实现图形化数据展示功能。

对于一个简单的静态图表模块类的实现可以参考 `apps.Example.model.StatiCharts` 
```java
@Model(code = "charts", icon = "line-chart",
        entrance = Chart.ACTION_CHART,
        menu = ExampleMain.MENU_1, order = 5,
        name = {"静态图表", "en:Static Charts"},
        info = {"静态图表", "en:Static Charts."})
public class StaticCharts extends ModelBase implements Chart {

    @ModelField(
            name = {"时间", "en:Time"},
            info = {"。", "en:."})
    public int time;
    
    @ModelField(
            search = true,
            input_type = InputType.number,
            name = {"sql", "en:sql"},
            info = {"查询语句。", "en:sql."})
    public int sql;

    @Override
    public void chartData(DataBuilder dataBuilder) {
        Request request = getAppContext().getCurrentRequest();
        String sql = request.getParameter("sql");
        int j = 10;
        try {
            j = Integer.parseInt(sql);
        } catch (Exception e) {
            System.err.println("参数需要数字类型的");
        }
        List<String> xValues = new ArrayList<>();
        for (int i = 0; i < j; i++) {
            xValues.add(i + "");
        }
        dataBuilder.setXAxis(xValues.toArray(new String[0]));    // 设置x轴数据

        for (int k = 0; k < j / 2; k++) {
            String group = String.valueOf((char) ('a' + k));
            List<String> list = new ArrayList<>();
            for (int i = 0; i < xValues.size(); i++) {
                list.add(String.valueOf(-i * k + ThreadLocalRandom.current().nextInt(20)));
            }
            dataBuilder.addLineData(group, list.toArray(new String[0]));    // 设置每个维度的数据
        }
    }
}
```
---

#### Combined
`qingzhou.api.type.Combined` 接口定义了一种组合数据的展示能力，
适用于需要同时呈现多种数据类型的场景（如详细信息、列表数据和 UML 图等）。
通过此接口，开发者可以构建具有丰富数据展示能力的模块，并灵活地定义如何展示这些数据。
[源代码](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/type/Combined.java)

##### 接口说明

| **项**    | **描述**                                                                   |
|----------|--------------------------------------------------------------------------|
| **接口名**  | `Combined`                                                               |
| **常量**   | `ACTION_COMBINED` - 用于标识组合数据展示操作。                                        |
| **方法**   | `void combinedData(String id, DataBuilder dataBuilder) throws Exception` |
| **方法描述** | 定义如何构建和组合不同类型的数据。                                                        |
| **参数**   | - `id`: 数据唯一标识符。<br>- `dataBuilder`: 数据构建器，用于生成组合数据。                     |
| **异常**   | 抛出 `Exception` 处理数据构建或组合中的异常。                                            |

---

###### **DataBuilder 接口**

| **方法**                                                    | **描述**                                                              |
|-----------------------------------------------------------|---------------------------------------------------------------------|
| `<T> T buildData(Class<? extends CombinedData> dataType)` | 根据指定的 `CombinedData` 类型构建数据实例，例如 `ShowData`、`UmlData` 或 `ListData`。 |
| `void addData(CombinedData data)`                         | 将构建的 `CombinedData` 实例添加到组合数据中。                                     |

---

###### **CombinedData 接口**

| **方法**                               | **描述**        |
|--------------------------------------|---------------|
| `CombinedData header(String header)` | 设置数据的标题。      |
| `CombinedData model(String model)`   | 设置与数据关联的模型名称。 |

---

###### **子接口说明**

| **接口名**    | **描述**       | **方法**                                                                                                    |
|------------|--------------|-----------------------------------------------------------------------------------------------------------|
| `ShowData` | 用于展示详细信息数据。  | - `void addData(String fieldName, String fieldValue)`：添加字段名称和对应的值。                                        |
| `UmlData`  | 用于展示 UML 数据。 | - `void setData(String umlData)`：设置 UML 数据内容。                                                             |
| `ListData` | 用于展示列表数据。    | - `void setFields(String[] fields)`：设置列表的字段名称。<br>- `void addFieldValues(String[] fieldValues)`：添加一行列表数据。 |

---

###### **实现示例**

| **项**           | **描述**                                         |
|-----------------|------------------------------------------------|
| **构建 ShowData** | 使用 `ShowData` 子接口，展示用户的详细信息，如姓名和邮箱等。           |
| **构建 ListData** | 使用 `ListData` 子接口，展示用户的交易记录列表，包括日期、金额和状态等字段。   |
| **构建 UmlData**  | 使用 `UmlData` 子接口，展示用户关系的 UML 图，例如用户关系网络的图形化表示。 |

---

###### **示例代码** ([apps.Example.model.TransactionCombination](https://gitee.com/openeuler/qingzhou/blob/master/apps/Example/src/main/java/qingzhou/app/model/TransactionCombination.java))

```java
/**
 * 实现 Combined 接口的组合数据展示方法。
 *
 * @param id 数据的唯一标识符。
 * @param dataBuilder 数据构建器，用于组合展示不同类型的数据。
 */
@Override
public void combinedData(String id, DataBuilder dataBuilder) {
   // 构建事务详情 (ShowData)
   ShowData showData = dataBuilder.buildData(ShowData.class);
   showData.model(TransactionCombination.code).header("事务信息"); // 设置模型和标题。
   showData.addData("id", "qqqqq11111");                       // 添加字段和对应的值。
   showData.addData("branchStatus", "回滚成功");
   showData.addData("initiatorApplication", "test-app");
   dataBuilder.addData(showData);                              // 将数据添加到组合数据中。

   // 构建事务图表 (UmlData)
   UmlData umlData = dataBuilder.buildData(UmlData.class);
   umlData.model(TransactionCombination.code).header("事务信息图片");
   umlData.setData("@startuml\nAlice -> Bob: test\n@enduml");  // 设置 UML 数据内容。
   dataBuilder.addData(umlData);

   // 构建事务相关联的分支事务列表 (ListData)
   ListData listData = dataBuilder.buildData(ListData.class);
   listData.model(TransactionCombination.code).header("全局事务相关联的分支事务");
   listData.setFields(new String[]{"id", "initiatorApplication", "branchStatus"}); // 设置字段名称。
   listData.addFieldValues(new String[]{"transaction11111", "stock-xa", "未知"});   // 添加一行数据。
   listData.addFieldValues(new String[]{"transaction22222", "order-xa", "分支事务一阶段失败"});
   dataBuilder.addData(listData);

   // 构建事务关联日志列表 (ListData)
   ListData listData2 = dataBuilder.buildData(ListData.class);
   listData2.model(User.code).header("全局事务关联日志");
   listData2.setFields(new String[]{"id", "phoneNumber", "position"});            // 设置字段名称。
   listData2.addFieldValues(new String[]{"2024-10-27 18:00:00", "transaction11111", "第1条日志"}); // 添加日志记录。
   listData2.addFieldValues(new String[]{"2024-10-28 09:00:00", "transaction22222", "第2条日志"});
   dataBuilder.addData(listData2);
}
```
---

#### Dashboard

`Dashboard` 接口用于定义数据面板（Dashboard）的数据结构与展示逻辑，支持基本信息、仪表盘、柱状图等多种类型的数据展示。
[源代码](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/type/Dashboard.java)

##### 接口详情

-  顶层接口 `Dashboard`

| **方法名**              | **描述**                             | **参数**                                           | **返回值**   |
|----------------------|------------------------------------|--------------------------------------------------|-----------|
| `void dashboardData` | 设置 Dashboard 的数据内容。                | `String id`：数据标识符<br>`DataBuilder builder`：数据构建器 | 无         |
| `int period` (默认实现)  | 返回 Dashboard 刷新的周期，默认值为 `2000` 毫秒。 | 无                                                | 刷新周期（毫秒）。 |

---

-  嵌套接口 `DataBuilder`

| **方法名**           | **描述**                    | **参数**                                                       | **返回值**                  |
|-------------------|---------------------------|--------------------------------------------------------------|--------------------------|
| `<T> T buildData` | 创建指定类型的 Dashboard 数据对象。   | `Class<? extends DashboardData> dataType`：Dashboard 数据的类型类对象 | 构建的 `DashboardData` 对象实例 |
| `void addData`    | 添加一组 Dashboard 数据对象到数据面板。 | `DashboardData[] dashboardDataList`：Dashboard 数据对象数组         | 无                        |

---

-  嵌套接口 `DashboardData`

| **方法名**               | **描述**              | **参数**                 | **返回值**               |
|-----------------------|---------------------|------------------------|-----------------------|
| `DashboardData title` | 设置 Dashboard 数据的标题。 | `String title`：数据的标题文本 | 当前 `DashboardData` 对象 |

---

- 嵌套接口 `Basic`

| **方法名**         | **描述**                  | **参数**                                 | **返回值**       |
|-----------------|-------------------------|----------------------------------------|---------------|
| `Basic addData` | 添加一个键值对数据到 Basic 数据对象中。 | `String key`：数据键<br>`String value`：数据值 | 当前 `Basic` 对象 |

---

- 嵌套接口 `Gauge`

| **方法名**         | **描述**                | **参数**                   | **返回值**       |
|-----------------|-----------------------|--------------------------|---------------|
| `Gauge info`    | 设置 Gauge 数据的描述信息。     | `String info`：描述信息       | 当前 `Gauge` 对象 |
| `Gauge fields`  | 设置 Gauge 数据的字段名称。     | `String[] fields`：字段数组   | 当前 `Gauge` 对象 |
| `Gauge addData` | 添加 Gauge 数据的值。        | `String[] data`：字段对应的值数组 | 当前 `Gauge` 对象 |
| `Gauge usedKey` | 设置用于 Gauge 显示的已用值字段名。 | `String usedKey`：字段名     | 当前 `Gauge` 对象 |
| `Gauge maxKey`  | 设置用于 Gauge 显示的最大值字段名。 | `String maxKey`：字段名      | 当前 `Gauge` 对象 |
| `Gauge unit`    | 设置 Gauge 数据的单位。       | `String unit`：单位字符串      | 当前 `Gauge` 对象 |

---

- 嵌套接口 `Histogram`

| **继承自** | **描述**                                  |
|---------|-----------------------------------------|
| `Gauge` | `Histogram` 是 `Gauge` 的扩展接口，表示柱状图类型的数据。 |

---

- 嵌套接口 `ShareDataset`

| **继承自** | **描述**                                         |
|---------|------------------------------------------------|
| `Basic` | `ShareDataset` 是 `Basic` 的扩展接口，用于表示共享数据集类型的数据。 |

---

##### 使用示例([apps.Example.model.Dashboard](https://gitee.com/openeuler/qingzhou/blob/master/apps/Example/src/main/java/qingzhou/app/model/Dashboard.java))

```java
public class Dashboard extends ModelBase implements qingzhou.api.type.Dashboard {

   /**
    * 实现 Dashboard 接口的核心方法，用于生成 Dashboard 数据。
    *
    * @param id         数据标识符
    * @param dataBuilder 数据构建器，用于构造 Dashboard 数据
    */
   @Override
   public void dashboardData(String id, DataBuilder dataBuilder) {
      Random random = new Random();

      // 构造基本信息数据（Basic）
      Basic basic = dataBuilder.buildData(Basic.class);
      basic.title("基础数据");
      String[] units = new String[]{"GB", "MB", "KB"};
      for (int i = 0; i < 6; i++) {
         basic.addData("key" + i, random.nextInt(10) + units[random.nextInt(2)]);
      }
      dataBuilder.addData(new Basic[]{basic}); // 添加到数据构建器中

      // 构造多组仪表盘数据（Gauge）
      Gauge[] gauges = new Gauge[5];
      for (int count = 0; count < 5; count++) {
         Gauge gauge = dataBuilder.buildData(Gauge.class);
         gauge.info("内存使用情况" + count).title("内存" + count)
                 .maxKey("max").unit("GB").usedKey("used")
                 .fields(new String[]{"name", "ip", "used", "max"});
         for (int i = 0; i < 4; i++) {
            int used = random.nextInt(10);
            int max = Math.max(used, random.nextInt(10)); // 确保最大值大于等于已用值
            gauge.addData(new String[]{"实例" + i, "127.0.0.1", String.valueOf(used), String.valueOf(max)});
         }
         gauges[count] = gauge;
      }
      dataBuilder.addData(gauges);

      // 构造多组柱状图数据（Histogram）
      Histogram[] histograms = new Histogram[2];
      for (int count = 0; count < 2; count++) {
         Histogram histogram = dataBuilder.buildData(Histogram.class);
         histogram.info("网络使用情况" + count).title("网络" + count)
                 .unit("MB").maxKey("max").usedKey("used")
                 .fields(new String[]{"name", "ip", "used", "max"});
         for (int i = 0; i < 4; i++) {
            int used = random.nextInt(100);
            int max = Math.max(used, random.nextInt(100)); // 确保最大值大于等于已用值
            histogram.addData(new String[]{"实例" + i, "127.0.0.1", String.valueOf(used), String.valueOf(max)});
         }
         histograms[count] = histogram;
      }
      dataBuilder.addData(histograms);

      // 构造硬盘使用情况的仪表盘数据
      Gauge[] gauges1 = new Gauge[2];
      for (int count = 0; count < 2; count++) {
         Gauge gauge = dataBuilder.buildData(Gauge.class);
         gauge.info("硬盘使用情况" + count).title("硬盘" + count)
                 .maxKey("max").unit("GB").usedKey("used")
                 .fields(new String[]{"name", "ip", "used", "max"});
         for (int i = 0; i < 4; i++) {
            int used = random.nextInt(10);
            int max = Math.max(used, random.nextInt(10));
            gauge.addData(new String[]{"实例" + i, "127.0.0.1", String.valueOf(used), String.valueOf(max)});
         }
         gauges1[count] = gauge;
      }
      dataBuilder.addData(gauges1);

      // 构造单个柱状图数据
      Histogram histogram = dataBuilder.buildData(Histogram.class);
      histogram.info("网络使用情况" + 3).title("网络" + 3)
              .unit("MB").usedKey("used")
              .fields(new String[]{"name", "ip", "used"});
      for (int i = 0; i < 4; i++) {
         histogram.addData(new String[]{"实例" + i, "127.0.0.1", String.valueOf(random.nextInt(100))});
      }
      dataBuilder.addData(new Histogram[]{histogram});

      // 构造销售数据
      Basic basic1 = dataBuilder.buildData(Basic.class);
      basic1.title("销售数据")
              .addData("销售额", random.nextInt(100) + "（万元）")
              .addData("销售量", random.nextInt(100) + "（套）")
              .addData("成交率", random.nextInt(100) + " %");
      dataBuilder.addData(new Basic[]{basic1});

      // 构造共享数据集（ShareDataset）
      ShareDataset[] shareDatasets = new ShareDataset[2];
      for (int count = 0; count < 2; count++) {
         ShareDataset shareDataset = dataBuilder.buildData(ShareDataset.class);
         shareDataset.title("数据集" + count);
         for (int i = 0; i < 4; i++) {
            shareDataset.addData("key" + i, String.valueOf(random.nextInt(10)));
         }
         shareDatasets[count] = shareDataset;
      }
      dataBuilder.addData(shareDatasets);
   }

   /**
    * 实现 Dashboard 刷新周期的方法，设置周期为 3000 毫秒。
    *
    * @return 刷新周期（毫秒）
    */
   @Override
   public int period() {
      return 3000;
   }
}
```

---

#### Option
`qingzhou.api.type.Option` 提供静态和动态选项数据的接口，用于根据不同字段名返回对应的选项数据。
[源代码](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/type/Option.java)

##### 方法列表

| 方法名称                         | 返回类型     | 参数              | 描述                     |
|------------------------------|----------|-----------------|------------------------|
| staticOptionFields()         | String[] | 无               | 返回一个包含所有静态选项字段名的字符串数组。 |
| dynamicOptionFields()        | String[] | 无               | 返回一个包含所有动态选项字段名的字符串数组。 |
| optionData(String fieldName) | Item[]   | fieldName：字段名称。 | 根据给定的字段名返回对应的选项数据。     |


##### 实现示例([apps.Example.model](https://gitee.com/openeuler/qingzhou/blob/master/apps/Example/src/main/java/qingzhou/app/model/User.java))

```java
@Override
public String[] staticOptionFields() {
   return new String[]{"gender", "checkbox", "position", "field", "operator", "customLabel"};
}

@Override
public String[] dynamicOptionFields() {
   return new String[]{"subjects2", "subjects3"};
}

@Override
public Item[] optionData(String fieldName) {
   switch (fieldName) {
      case "gender":
         return new Item[]{
                 Item.of("0", new String[]{"男", "en:man"}),
                 Item.of("1", new String[]{"女", "en:woman"})
         };
      case "checkbox":
         return Item.of(new String[]{
                 "java", "python", "js"
         });
      case "subjects2":
         return new Item[]{
                 Item.of("1", new String[]{"一", "en:One"}),
                 Item.of("2", new String[]{"二", "en:Two"}),
                 Item.of("3", new String[]{"三", "en:Three"})
         };
      case "subjects3":
         return Item.of(new String[]{"a", "b", "c", "d", "e"});
      case "position": // 没有设置静态和动态选项字段，无效代码
         return new Item[]{
                 Item.of("001", new String[]{"开发", "en:Dev"}),
                 Item.of("002", new String[]{"测试", "en:Test"}),
         };
      case "field":
         return Item.of(new String[]{"gender", "position", "checkbox"});
      case "operator":
         return Item.of(new String[]{">", "=", "<", "<=", "!=", "in", "not in", "like", "not like", "is null", "is not null"});
      case "customLabel":
         return Item.of(new String[]{"true", "false"});
   }

   return null;
}
```

---

#### Validate
`qingzhou.api.type.Validate` 定义了数据验证的能力，提供验证方法以确保数据的有效性。

##### 方法

| 方法名称                      | 返回类型                | 参数            | 描述                            |
|---------------------------|---------------------|---------------|-------------------------------|
| validate(Request request) | Map<String, String> | request：请求对象。 | 根据请求对象验证数据的有效性，并返回验证结果的键值对集合。 |

---

### API
#### ActionFilter
`qingzhou.api.ActionFilter` 接口定义了用于处理请求和响应的过滤器行为。 
过滤器通常应用于预处理阶段，例如权限验证、参数校验等。[Javadoc](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/ActionFilter.java)

##### 方法

| 方法名称                      | 返回类型   | 描述                                                                                 |
|---------------------------|--------|------------------------------------------------------------------------------------|
| doFilter(Request request) | String | 执行过滤操作的方法。此方法会在请求处理前被调用，允许对传入的Request对象进行修改，并可以利用AppContext获取到应用程序上下文信息以辅助过滤逻辑的执行。 |

#### AppContext
`qingzhou.api.AppContext` 应用上下文接口，提供应用元数据、平台信息获取，以及服务定位、临时文件管理、国际化信息、菜单管理和动作过滤器管理等功能。
[Javadoc](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/AppContext.java)

以下是 `AppContext` 接口列表

| **接口方法**                                         | **返回类型**               | **参数**                                         | **说明**                                    |
|--------------------------------------------------|------------------------|------------------------------------------------|-------------------------------------------|
| `getCurrentRequest()`                            | `Request`              | 无                                              | 获取当前的请求对象。                                |
| `getAppDir()`                                    | `File`                 | 无                                              | 获取应用程序的目录文件对象。如果无法确定或创建应用程序目录，则返回 `null`。 |
| `getTemp()`                                      | `File`                 | 无                                              | 获取临时文件目录的文件对象。                            |
| `addActionFilter(ActionFilter actionFilter)`     | `void`                 | `actionFilter`：操作过滤器实例                         | 添加一个操作过滤器，用于拦截和处理请求的操作。                   |
| `addI18n(String key, String[] i18n)`             | `void`                 | `key`：国际化信息的键<br>`i18n`：国际化信息的值数组              | 添加国际化信息。将指定的键与其对应的国际化信息绑定，以供不同语言版本使用。     |
| `getI18n(Lang lang, String key, Object... args)` | `String`               | `lang`：语言类型<br>`key`：国际化信息的键<br>`args`：可选的动态参数 | 根据给定的语言类型和键，获取国际化信息并替换参数。                 |
| `getI18n(String key, Object... args)`            | `String`               | `key`：国际化信息的键<br>`args`：可选的动态参数                | 根据当前请求的语言设置，获取对应的国际化信息并替换参数。              |
| `addMenu(String name, String[] i18n)`            | `Menu`                 | `name`：菜单项名称<br>`i18n`：国际化信息数组                 | 添加一个菜单项，设置菜单项的名称和对应的国际化信息。此方法在启动过程中调用有效。  |
| `getService(Class<T> clazz)`                     | `T`                    | `clazz`：服务的类类型                                 | 获取本模块开放的服务，或从其它模块注入的服务。                   |
| `getServiceTypes()`                              | `Collection<Class<?>>` | 无                                              | 获取本模块提供的所有服务的类型集合。                        |
| `invokeSuperAction(Request request)`             | `void`                 | `request`：请求对象                                 | 调用父类的操作方法，用于处理特定请求。                       |
| `getPlatformVersion()`                           | `String`               | 无                                              | 获取当前平台的版本信息。                              |

##### 用法示例
   ```java
public class ExampleMain implements QingzhouApp {
   public static final String MENU_1 = "MENU_1";
   public static final String MENU_11 = "MENU_11";
   
   @Override
   public void start(AppContext appContext) {
       appContext.addMenu(MENU_1, new String[]{"一级菜单", "en:1"}).icon("folder-open").order(1);
       appContext.addMenu(MENU_11, new String[]{"二级菜单", "en:11"}).icon("leaf").order(1).parent(MENU_1);

       appContext.addActionFilter(request -> {
           String msg = String.format("有请求进入，模块：%s，操作：%s", request.getModel(), request.getAction());
           return null; // null 表示无异常
       });
   }}
   ```

---

#### Item
`qingzhou.api.Item` 用于表示页面表单字段的项目，该项目具有名称和国际化信息。
[Javadoc](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/Item.java)

方法列表：

| 方法名                                          | 描述                           | 参数                                       | 返回值                                                            | 示例                                                                                                                                  |
|----------------------------------------------|------------------------------|------------------------------------------|----------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------|
| `String name()`                              | 获取表单字段项目的名称。                 | 无                                        | 返回表单字段项目的名称。                                                   | `name()` 返回字段名称，例如 `"email"`。                                                                                                       |
| `String[] i18n()`                            | 获取表单字段项目的国际化信息数组。            | 无                                        | 返回表单字段项目的国际化信息数组，每个元素代表不同语言环境下的名称。                             | `i18n()` 返回一个数组，如 `["en:email", "zh:电子邮件"]`。                                                                                        |
| `static Item of(String name)`                | 根据提供的名称创建一个表单字段项目实例。         | `name`（表单字段项目的名称）                        | 返回一个新的 `Item` 实例，其中 `name()` 方法返回指定的名称，`i18n()` 方法生成国际化信息数组。   | `Item.of("email")` 返回一个 `Item` 实例，`name()` 返回 `"email"`，`i18n()` 返回数组 `["en:email", "zh:电子邮件"]`。                                    |
| `static Item[] of(String[] names)`           | 根据提供的名称数组创建多个表单字段项目实例。       | `names`（表单字段项目名称数组）                      | 返回一个 `Item` 数组，数组中的每个元素都是通过 `of(String name)` 方法创建的 `Item` 实例。 | `Item.of(new String[]{"email", "password"})` 返回一个包含两个 `Item` 实例的数组，分别表示 `"email"` 和 `"password"` 字段。                                |
| `static Item of(String name, String[] i18n)` | 根据提供的名称和国际化信息数组创建一个表单字段项目实例。 | `name`（表单字段项目的名称）、`i18n`（表单字段项目的国际化信息数组） | 返回一个新的 `Item` 实例，其中 `name()` 返回指定的名称，`i18n()` 返回指定的国际化信息数组。    | `Item.of("email", new String[]{"en:email", "zh:电子邮件"})` 返回一个 `Item` 实例，`name()` 返回 `"email"`，`i18n()` 返回 `["en:email", "zh:电子邮件"]`。 |

---
#### QingzhouApp
`qingzhou.api.QingzhouApp` 应用抽象类，定义了应用的启动和停止操作。[Javadoc](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/QingzhouApp.java)

以下是 `QingzhouApp` 接口方法列表：

| **接口方法**                       | **返回类型** | **参数**                           | **说明**                                                     |
|--------------------------------|----------|----------------------------------|------------------------------------------------------------|
| `start(AppContext appContext)` | `void`   | `appContext`：应用上下文，提供启动时所需的环境和配置 | 启动应用程序。此方法在启动时调用，并传入应用上下文，提供启动所需的配置和环境信息。                  |
| `stop()`                       | `void`   | 无                                | 停止应用程序并执行必要的清理工作，如释放资源。此方法有默认实现为空，子类可以根据需要重写此方法来定义具体的停止逻辑。 |

---
#### Request
`qingzhou.api.Request` 请求接口定义了获取请求相关信息的方法。
详细的方法列表可查看[Javadoc](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/Request.java)

```java
String targetAppName = request.getApp();
String msg = checkPwd(password, request.getUser());
```
---
#### Response
`qingzhou.api.Response` 响应接口定义了操作响应结果的方法。主要用于设置响应的成功状态、消息、总数、分页信息以及数据添加。
[Javadoc](https://gitee.com/openeuler/qingzhou/blob/master/qingzhou-api/src/main/java/qingzhou/api/Response.java)

以下是 `Response` 方法列表：

| **接口方法**                                | **返回类型** | **参数**                                            | **说明**                                                               |
|-----------------------------------------|----------|---------------------------------------------------|----------------------------------------------------------------------|
| `setSuccess(boolean success)`           | `void`   | `success`：操作是否成功的状态 (boolean)                     | 设置操作的成功状态，`true` 表示操作成功，`false` 表示操作失败。                              |
| `setMsg(String msg)`                    | `void`   | `msg`：返回的消息 (String)                              | 设置操作的返回消息，用于向客户端反馈操作的详细信息。                                           |
| `setMsgLevel(MsgLevel msgLevel)`        | `void`   | `msgLevel`：消息等级 (MsgLevel)                        | 设置消息的等级，`MsgLevel` 是一个枚举类型，通常包含 `INFO`、`WARN`、`ERROR` 等，用于标明消息的严重程度。 |
| `setContentType(String contentType)`    | `void`   | `contentType`：响应内容类型 (String)                     | 设置响应的内容类型（如 `application/json`、`text/html` 等）。                       |
| `setHeader(String name, String value)`  | `void`   | `name`：头部字段名称 (String)<br>`value`：字段值 (String)    | 设置响应头部信息，传入字段名称及其对应的值。                                               |
| `setDateHeader(String name, long date)` | `void`   | `name`：头部字段名称 (String)<br>`date`：日期值，单位为毫秒 (long) | 设置响应头部中的日期字段，`date` 是自 1970 年 1 月 1 日以来的毫秒数。                         |
| `setData(Serializable data)`            | `void`   | `data`：响应数据，必须是 `Serializable` 类型                 | 设置响应的具体数据，通常用于返回对象、数组等序列化数据。                                         |

